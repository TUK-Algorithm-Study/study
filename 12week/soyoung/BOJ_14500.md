# BOJ - 14500

[14500번: 테트로미노](https://www.acmicpc.net/problem/14500)

### 문제

- 테트로미노
    - 테트로미노 하나를 이용해 테트로미노가 놓인 칸에 쓰여 있는 수들의 합의 최대 구하기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/260f95da-1c31-4fa1-bbac-5cb1c4e9da6a/Untitled.png)

- 입력
    - n, m : 배열 크기
    - n x m : 배열의 값
    
- 출력
    - 테트로미노가 놓인 칸에 쓰여있는 수의 합의 최대
    

### 접근

- 구현 (놀랍게도 또 구현)
    - 5가지 종류의 테트로미노를 모든 칸에 대해 적용시켜 보고 최댓값을 구함
    - 회전 혹은 대칭이 되므로 여러가지의 경우를 모두 고려해봄

```jsx
#include <iostream>
using namespace std;

int ma,n,m;
int arr[500][500];

void l1(){
	for (int i=0;i<n;i++)
		for (int j=0;j<m-3;j++)
			ma=max(ma,arr[i][j]+arr[i][j+1]+arr[i][j+2]+arr[i][j+3]);
}

void l2(){
	for (int i=0;i<n-3;i++)
		for (int j=0;j<m;j++)
			ma=max(ma,arr[i][j]+arr[i+1][j]+arr[i+2][j]+arr[i+3][j]);
}

void nemo(){
	for (int i=0;i<n-1;i++)
		for (int j=0;j<m-1;j++)
			ma=max(ma,arr[i][j]+arr[i+1][j]+arr[i][j+1]+arr[i+1][j+1]);
}

void L1(){
	for (int i=0;i<n-2;i++)
		for (int j=0;j<m-1;j++)
			ma=max(ma,arr[i][j]+arr[i+1][j]+arr[i+2][j]+arr[i+2][j+1]);
}

void L2(){
	for (int i=0;i<n-1;i++)
		for (int j=0;j<m-2;j++)
			ma=max(ma,arr[i][j]+arr[i+1][j]+arr[i][j+1]+arr[i][j+2]);
}

void L3(){
	for (int i=0;i<n-2;i++)
		for (int j=0;j<m-1;j++)
			ma=max(ma,arr[i][j]+arr[i][j+1]+arr[i+1][j+1]+arr[i+2][j+1]);
}

void L4(){
	for (int i=0;i<n-1;i++)
		for (int j=0;j<m-2;j++)
			ma=max(ma,arr[i+1][j]+arr[i+1][j+1]+arr[i+1][j+2]+arr[i][j+2]);
}

void L5(){
	for (int i=0;i<n-2;i++)
		for (int j=0;j<m-1;j++)
			ma=max(ma,arr[i+2][j]+arr[i+2][j+1]+arr[i+1][j+1]+arr[i][j+1]);
}

void L6(){
	for (int i=0;i<n-1;i++)
		for (int j=0;j<m-2;j++)
			ma=max(ma,arr[i][j]+arr[i+1][j]+arr[i+1][j+1]+arr[i+1][j+2]);
}

void L7(){
	for (int i=0;i<n-2;i++)
		for (int j=0;j<m-1;j++)
			ma=max(ma,arr[i][j]+arr[i][j+1]+arr[i+1][j]+arr[i+2][j]);
}

void L8(){
	for (int i=0;i<n-1;i++)
		for (int j=0;j<m-2;j++)
			ma=max(ma,arr[i][j]+arr[i][j+1]+arr[i][j+2]+arr[i+1][j+2]);
}

void z1(){
	for (int i=0;i<n-2;i++)
		for (int j=0;j<m-1;j++)
			ma=max(ma,arr[i][j]+arr[i+1][j]+arr[i+1][j+1]+arr[i+2][j+1]);
}

void z2(){
	for (int i=0;i<n-1;i++)
		for (int j=0;j<m-2;j++)
			ma=max(ma,arr[i+1][j]+arr[i+1][j+1]+arr[i][j+1]+arr[i][j+2]);
}

void z3(){
	for (int i=0;i<n-2;i++)
		for (int j=0;j<m-1;j++)
			ma=max(ma,arr[i][j+1]+arr[i+1][j+1]+arr[i+1][j]+arr[i+2][j]);
}

void z4(){
	for (int i=0;i<n-1;i++)
		for (int j=0;j<m-2;j++)
			ma=max(ma,arr[i][j]+arr[i][j+1]+arr[i+1][j+1]+arr[i+1][j+2]);
}

void T1(){
	for (int i=0;i<n-1;i++)
		for (int j=0;j<m-2;j++)
			ma=max(ma,arr[i][j]+arr[i][j+1]+arr[i][j+2]+arr[i+1][j+1]);
}

void T2(){
	for (int i=0;i<n-1;i++)
		for (int j=0;j<m-2;j++)
			ma=max(ma,arr[i+1][j]+arr[i+1][j+1]+arr[i+1][j+2]+arr[i][j+1]);
}

void T3(){
	for (int i=0;i<n-2;i++)
		for (int j=0;j<m-1;j++)
			ma=max(ma,arr[i][j]+arr[i+1][j]+arr[i+2][j]+arr[i+1][j+1]);
}

void T4(){
	for (int i=0;i<n-2;i++)
		for (int j=0;j<m-1;j++)
			ma=max(ma,arr[i][j+1]+arr[i+1][j+1]+arr[i+2][j+1]+arr[i+1][j]);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	cin>>n>>m;
	for (int i=0;i<n;i++)
		for (int j=0;j<m;j++) cin>>arr[i][j];
	
	l1();l2();
	nemo();
	L1();L2();L3();L4();L5();L6();L7();L8();
	z1();z2();z3();z4();
	T1();T2();T3();T4();
	
	cout<<ma;
}
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f5a2929c-3bc6-4036-8269-a1c727148be0/Untitled.png)

// 가로세로 크기를 고려해 각각의 함수를 나누지 않아도 될 것 같다는 생각…?

### DFS (ONLY)
